// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f https://github.com/piraeusdatastore/piraeus-operator/releases/download/v2.9.0/manifest.yaml

package v1

import "strings"

// LinstorCluster is the Schema for the linstorclusters API
#LinstorCluster: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "piraeus.io/v1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "LinstorCluster"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// LinstorClusterSpec defines the desired state of LinstorCluster
	spec!: #LinstorClusterSpec
}

// LinstorClusterSpec defines the desired state of LinstorCluster
#LinstorClusterSpec: {
	// ApiTLS secures the LINSTOR API.
	//
	// This configures the TLS key and certificate used to secure the
	// LINSTOR API.
	apiTLS?: null | {
		// ApiSecretName references a secret holding the TLS key and
		// certificate used to protect the API.
		// Defaults to "linstor-api-tls".
		apiSecretName?: string

		// CAReference configures the CA certificate to use when
		// validating TLS certificates.
		// If not set, the TLS secret is expected to contain a "ca.crt"
		// containing the CA certificate.
		caReference?: {
			// Key to select in the resource.
			// Defaults to ca.crt if not specified.
			key?: string

			// Kind of the resource containing the CA Certificate, either a
			// ConfigMap or Secret.
			kind?: "ConfigMap" | "Secret"

			// Name of the resource containing the CA Certificate.
			name!: string

			// Optional specifies whether the resource and its key must exist.
			optional?: bool
		}

		// CertManager references a cert-manager Issuer or ClusterIssuer.
		// If set, cert-manager.io/Certificate resources will be created,
		// provisioning the secrets referenced in
		// *SecretName using the issuer configured here.
		certManager?: {
			// Group of the resource being referred to.
			group?: string

			// Kind of the resource being referred to.
			kind?: string

			// Name of the resource being referred to.
			name!: string
		}

		// ClientSecretName references a secret holding the TLS key and
		// certificate used by the operator to configure
		// the cluster. Defaults to "linstor-client-tls".
		clientSecretName?: string

		// CsiControllerSecretName references a secret holding the TLS key
		// and certificate used by the CSI Controller
		// to provision volumes. Defaults to "linstor-csi-controller-tls".
		csiControllerSecretName?: string

		// CsiNodeSecretName references a secret holding the TLS key and
		// certificate used by the CSI Nodes to query
		// the volume state. Defaults to "linstor-csi-node-tls".
		csiNodeSecretName?: string
	}

	// Controller controls the deployment of the LINSTOR Controller
	// Deployment.
	controller?: {
		// Enable the component.
		enabled?: bool

		// Template to apply to Pods of the component.
		//
		// The template is applied as a patch to the default deployment,
		// so it can be "sparse", not listing any
		// containers or volumes that should remain unchanged.
		// See
		// https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates
		podTemplate?: {
			...
		}
	}

	// CSIController controls the deployment of the CSI Controller
	// Deployment.
	csiController?: {
		// Enable the component.
		enabled?: bool

		// Template to apply to Pods of the component.
		//
		// The template is applied as a patch to the default deployment,
		// so it can be "sparse", not listing any
		// containers or volumes that should remain unchanged.
		// See
		// https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates
		podTemplate?: {
			...
		}
	}

	// CSINode controls the deployment of the CSI Node DaemonSet.
	csiNode?: {
		// Enable the component.
		enabled?: bool

		// Template to apply to Pods of the component.
		//
		// The template is applied as a patch to the default deployment,
		// so it can be "sparse", not listing any
		// containers or volumes that should remain unchanged.
		// See
		// https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates
		podTemplate?: {
			...
		}
	}
	externalController?: {
		// URL of the external controller.
		url!: strings.MinRunes(3)
	}

	// HighAvailabilityController controls the deployment of the High
	// Availability Controller DaemonSet.
	highAvailabilityController?: {
		// Enable the component.
		enabled?: bool

		// Template to apply to Pods of the component.
		//
		// The template is applied as a patch to the default deployment,
		// so it can be "sparse", not listing any
		// containers or volumes that should remain unchanged.
		// See
		// https://kubernetes.io/docs/concepts/workloads/pods/#pod-templates
		podTemplate?: {
			...
		}
	}

	// InternalTLS secures the connection between LINSTOR Controller
	// and Satellite.
	//
	// This configures the client certificate used when the Controller
	// connects to a Satellite. This only has an effect
	// when the Satellite is configured to for secure connections
	// using `LinstorSatellite.spec.internalTLS`.
	internalTLS?: null | {
		// CAReference configures the CA certificate to use when
		// validating TLS certificates.
		// If not set, the TLS secret is expected to contain a "ca.crt"
		// containing the CA certificate.
		caReference?: {
			// Key to select in the resource.
			// Defaults to ca.crt if not specified.
			key?: string

			// Kind of the resource containing the CA Certificate, either a
			// ConfigMap or Secret.
			kind?: "ConfigMap" | "Secret"

			// Name of the resource containing the CA Certificate.
			name!: string

			// Optional specifies whether the resource and its key must exist.
			optional?: bool
		}

		// CertManager references a cert-manager Issuer or ClusterIssuer.
		// If set, a Certificate resource will be created, provisioning
		// the secret references in SecretName using the
		// issuer configured here.
		certManager?: {
			// Group of the resource being referred to.
			group?: string

			// Kind of the resource being referred to.
			kind?: string

			// Name of the resource being referred to.
			name!: string
		}

		// SecretName references a secret holding the TLS key and
		// certificates.
		secretName?: string
	}

	// LinstorPassphraseSecret used to configure the LINSTOR master
	// passphrase.
	//
	// The referenced secret must contain a single key
	// "MASTER_PASSPHRASE". The master passphrase is used to
	// * Derive encryption keys for volumes using the LUKS layer.
	// * Store credentials for accessing remotes for backups.
	// See
	// https://linbit.com/drbd-user-guide/linstor-guide-1_0-en/#s-encrypt_commands
	// for more information.
	linstorPassphraseSecret?: string
	nodeAffinity?: {
		// Required. A list of node selector terms. The terms are ORed.
		nodeSelectorTerms!: [...{
			// A list of node selector requirements by node's labels.
			matchExpressions?: [...{
				// The label key that the selector applies to.
				key!: string

				// Represents a key's relationship to a set of values.
				// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
				// Lt.
				operator!: string

				// An array of string values. If the operator is In or NotIn,
				// the values array must be non-empty. If the operator is Exists
				// or DoesNotExist,
				// the values array must be empty. If the operator is Gt or Lt,
				// the values
				// array must have a single element, which will be interpreted as
				// an integer.
				// This array is replaced during a strategic merge patch.
				values?: [...string]
			}]

			// A list of node selector requirements by node's fields.
			matchFields?: [...{
				// The label key that the selector applies to.
				key!: string

				// Represents a key's relationship to a set of values.
				// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
				// Lt.
				operator!: string

				// An array of string values. If the operator is In or NotIn,
				// the values array must be non-empty. If the operator is Exists
				// or DoesNotExist,
				// the values array must be empty. If the operator is Gt or Lt,
				// the values
				// array must have a single element, which will be interpreted as
				// an integer.
				// This array is replaced during a strategic merge patch.
				values?: [...string]
			}]
		}]
	}

	// NodeSelector selects the nodes on which LINSTOR Satellites will
	// be deployed.
	// See
	// https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	nodeSelector?: {
		[string]: string
	}

	// Patches is a list of kustomize patches to apply.
	//
	// See
	// https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patches/
	// for how to create patches.
	patches?: [...{
		// Options is a list of options for the patch
		options?: {
			[string]: bool
		}

		// Patch is the content of a patch.
		patch!: strings.MinRunes(1)

		// Target points to the resources that the patch is applied to
		target?: {
			// AnnotationSelector is a string that follows the label selection
			// expression
			// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
			// It matches against the resource annotations.
			annotationSelector?: string
			group?:              string
			kind?:               string

			// LabelSelector is a string that follows the label selection
			// expression
			// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api
			// It matches against the resource labels.
			labelSelector?: string

			// Name of the resource.
			name?: string

			// Namespace the resource belongs to, if it can belong to a
			// namespace.
			namespace?: string
			version?:   string
		}
	}]

	// Properties to apply on the cluster level.
	//
	// Use to create default settings for DRBD that should apply to
	// all resources or to configure some other cluster
	// wide default.
	properties?: [...{
		// Name of the property to set.
		name!: strings.MinRunes(1)

		// Value to set the property to.
		value?: string
	}]

	// Repository used to pull workload images.
	repository?: string

	// Tolerations selects the nodes on which LINSTOR Satellites will
	// be deployed.
	//
	// The default tolerations for DaemonSets are automatically added.
	tolerations?: [...{
		// Effect indicates the taint effect to match. Empty means match
		// all taint effects.
		// When specified, allowed values are NoSchedule, PreferNoSchedule
		// and NoExecute.
		effect?: string

		// Key is the taint key that the toleration applies to. Empty
		// means match all taint keys.
		// If the key is empty, operator must be Exists; this combination
		// means to match all values and all keys.
		key?: string

		// Operator represents a key's relationship to the value.
		// Valid operators are Exists and Equal. Defaults to Equal.
		// Exists is equivalent to wildcard for value, so that a pod can
		// tolerate all taints of a particular category.
		operator?: string

		// TolerationSeconds represents the period of time the toleration
		// (which must be
		// of effect NoExecute, otherwise this field is ignored) tolerates
		// the taint. By default,
		// it is not set, which means tolerate the taint forever (do not
		// evict). Zero and
		// negative values will be treated as 0 (evict immediately) by the
		// system.
		tolerationSeconds?: int64

		// Value is the taint value the toleration matches to.
		// If the operator is Exists, the value should be empty, otherwise
		// just a regular string.
		value?: string
	}]
}
