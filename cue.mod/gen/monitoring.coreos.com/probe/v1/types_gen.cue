// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f https://github.com/prometheus-community/helm-charts/raw/refs/heads/main/charts/kube-prometheus-stack/charts/crds/crds/crd-probes.yaml

package v1

import "strings"

// The `Probe` custom resource definition (CRD) defines how to
// scrape metrics from prober exporters such as the [blackbox
// exporter](https://github.com/prometheus/blackbox_exporter).
//
// The `Probe` resource needs 2 pieces of information:
// * The list of probed addresses which can be defined statically
// or by discovering Kubernetes Ingress objects.
// * The prober which exposes the availability of probed endpoints
// (over various protocols such HTTP, TCP, ICMP, ...) as
// Prometheus metrics.
//
// `Prometheus` and `PrometheusAgent` objects select `Probe`
// objects using label and namespace selectors.
#Probe: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "monitoring.coreos.com/v1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "Probe"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// Specification of desired Ingress selection for target discovery
	// by Prometheus.
	spec!: #ProbeSpec
}

// Specification of desired Ingress selection for target discovery
// by Prometheus.
#ProbeSpec: {
	// Authorization section for this endpoint
	authorization?: {
		// Selects a key of a Secret in the namespace that contains the
		// credentials for authentication.
		credentials?: {
			// The key of the secret to select from. Must be a valid secret
			// key.
			key!: string

			// Name of the referent.
			// This field is effectively required, but due to backwards
			// compatibility is
			// allowed to be empty. Instances of this type with an empty value
			// here are
			// almost certainly wrong.
			// More info:
			// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			name?: string

			// Specify whether the Secret or its key must be defined
			optional?: bool
		}

		// Defines the authentication type. The value is case-insensitive.
		//
		// "Basic" is not a supported value.
		//
		// Default: "Bearer"
		type?: string
	}

	// BasicAuth allow an endpoint to authenticate over basic
	// authentication.
	// More info:
	// https://prometheus.io/docs/operating/configuration/#endpoint
	basicAuth?: {
		// `password` specifies a key of a Secret containing the password
		// for
		// authentication.
		password?: {
			// The key of the secret to select from. Must be a valid secret
			// key.
			key!: string

			// Name of the referent.
			// This field is effectively required, but due to backwards
			// compatibility is
			// allowed to be empty. Instances of this type with an empty value
			// here are
			// almost certainly wrong.
			// More info:
			// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			name?: string

			// Specify whether the Secret or its key must be defined
			optional?: bool
		}

		// `username` specifies a key of a Secret containing the username
		// for
		// authentication.
		username?: {
			// The key of the secret to select from. Must be a valid secret
			// key.
			key!: string

			// Name of the referent.
			// This field is effectively required, but due to backwards
			// compatibility is
			// allowed to be empty. Instances of this type with an empty value
			// here are
			// almost certainly wrong.
			// More info:
			// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			name?: string

			// Specify whether the Secret or its key must be defined
			optional?: bool
		}
	}

	// Secret to mount to read bearer token for scraping targets. The
	// secret
	// needs to be in the same namespace as the probe and accessible
	// by
	// the Prometheus Operator.
	bearerTokenSecret?: {
		// The key of the secret to select from. Must be a valid secret
		// key.
		key!: string

		// Name of the referent.
		// This field is effectively required, but due to backwards
		// compatibility is
		// allowed to be empty. Instances of this type with an empty value
		// here are
		// almost certainly wrong.
		// More info:
		// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
		name?: string

		// Specify whether the Secret or its key must be defined
		optional?: bool
	}

	// Whether to convert all scraped classic histograms into a native
	// histogram with custom buckets.
	// It requires Prometheus >= v3.0.0.
	convertClassicHistogramsToNHCB?: bool

	// The protocol to use if a scrape returns blank, unparseable, or
	// otherwise invalid Content-Type.
	//
	// It requires Prometheus >= v3.0.0.
	fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0"

	// Interval at which targets are probed using the configured
	// prober.
	// If not specified Prometheus' global scrape interval is used.
	interval?: =~"^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"

	// The job name assigned to scraped metrics by default.
	jobName?: string

	// Per-scrape limit on the number of targets dropped by relabeling
	// that will be kept in memory. 0 means no limit.
	//
	// It requires Prometheus >= v2.47.0.
	keepDroppedTargets?: int64

	// Per-scrape limit on number of labels that will be accepted for
	// a sample.
	// Only valid in Prometheus versions 2.27.0 and newer.
	labelLimit?: int64

	// Per-scrape limit on length of labels name that will be accepted
	// for a sample.
	// Only valid in Prometheus versions 2.27.0 and newer.
	labelNameLengthLimit?: int64

	// Per-scrape limit on length of labels value that will be
	// accepted for a sample.
	// Only valid in Prometheus versions 2.27.0 and newer.
	labelValueLengthLimit?: int64

	// MetricRelabelConfigs to apply to samples before ingestion.
	metricRelabelings?: [...{
		// Action to perform based on the regex matching.
		//
		// `Uppercase` and `Lowercase` actions require Prometheus >=
		// v2.36.0.
		// `DropEqual` and `KeepEqual` actions require Prometheus >=
		// v2.41.0.
		//
		// Default: "Replace"
		action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual"

		// Modulus to take of the hash of the source label values.
		//
		// Only applicable when the action is `HashMod`.
		modulus?: int64

		// Regular expression against which the extracted value is
		// matched.
		regex?: string

		// Replacement value against which a Replace action is performed
		// if the
		// regular expression matches.
		//
		// Regex capture groups are available.
		replacement?: string

		// Separator is the string between concatenated SourceLabels.
		separator?: string

		// The source labels select values from existing labels. Their
		// content is
		// concatenated using the configured Separator and matched against
		// the
		// configured regular expression.
		sourceLabels?: [...=~"^[a-zA-Z_][a-zA-Z0-9_]*$"]

		// Label to which the resulting string is written in a
		// replacement.
		//
		// It is mandatory for `Replace`, `HashMod`, `Lowercase`,
		// `Uppercase`,
		// `KeepEqual` and `DropEqual` actions.
		//
		// Regex capture groups are available.
		targetLabel?: string
	}]

	// The module to use for probing specifying how to probe the
	// target.
	// Example module configuring in the blackbox exporter:
	// https://github.com/prometheus/blackbox_exporter/blob/master/example.yml
	module?: string

	// If there are more than this many buckets in a native histogram,
	// buckets will be merged to stay within the limit.
	// It requires Prometheus >= v2.45.0.
	nativeHistogramBucketLimit?: int64

	// If the growth factor of one bucket to the next is smaller than
	// this,
	// buckets will be merged to increase the factor sufficiently.
	// It requires Prometheus >= v2.50.0.
	nativeHistogramMinBucketFactor?: matchN(>=1, [int, string]) & (number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$")

	// OAuth2 for the URL. Only valid in Prometheus versions 2.27.0
	// and newer.
	oauth2?: {
		// `clientId` specifies a key of a Secret or ConfigMap containing
		// the
		// OAuth2 client's ID.
		clientId!: {
			// ConfigMap containing data to use for the targets.
			configMap?: {
				// The key to select.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the ConfigMap or its key must be defined
				optional?: bool
			}

			// Secret containing data to use for the targets.
			secret?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}
		}

		// `clientSecret` specifies a key of a Secret containing the
		// OAuth2
		// client's secret.
		clientSecret!: {
			// The key of the secret to select from. Must be a valid secret
			// key.
			key!: string

			// Name of the referent.
			// This field is effectively required, but due to backwards
			// compatibility is
			// allowed to be empty. Instances of this type with an empty value
			// here are
			// almost certainly wrong.
			// More info:
			// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			name?: string

			// Specify whether the Secret or its key must be defined
			optional?: bool
		}

		// `endpointParams` configures the HTTP parameters to append to
		// the token
		// URL.
		endpointParams?: {
			[string]: string
		}

		// `noProxy` is a comma-separated string that can contain IPs,
		// CIDR notation, domain names
		// that should be excluded from proxying. IP and domain names can
		// contain port numbers.
		//
		// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or
		// Thanos >= v0.32.0.
		noProxy?: string

		// ProxyConnectHeader optionally specifies headers to send to
		// proxies during CONNECT requests.
		//
		// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or
		// Thanos >= v0.32.0.
		proxyConnectHeader?: {
			[string]: [...{
				// The key of the secret to select from. Must be a valid secret
				// key.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}]
		}

		// Whether to use the proxy configuration defined by environment
		// variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
		//
		// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or
		// Thanos >= v0.32.0.
		proxyFromEnvironment?: bool

		// `proxyURL` defines the HTTP proxy server to use.
		proxyUrl?: =~"^(http|https|socks5)://.+$"

		// `scopes` defines the OAuth2 scopes used for the token request.
		scopes?: [...string]

		// TLS configuration to use when connecting to the OAuth2 server.
		// It requires Prometheus >= v2.43.0.
		tlsConfig?: {
			// Certificate authority used when verifying server certificates.
			ca?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Client certificate to present when doing client-authentication.
			cert?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Disable target certificate validation.
			insecureSkipVerify?: bool

			// Secret containing the client key file for the targets.
			keySecret?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// Maximum acceptable TLS version.
			//
			// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
			maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13"

			// Minimum acceptable TLS version.
			//
			// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
			minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13"

			// Used to verify the hostname for the targets.
			serverName?: string
		}

		// `tokenURL` configures the URL to fetch the token from.
		tokenUrl!: strings.MinRunes(1)
	}

	// The list of HTTP query parameters for the scrape.
	// Please note that the `.spec.module` field takes precedence over
	// the `module` parameter from this list when both are defined.
	// The module name must be added using Module under ProbeSpec.
	params?: [...{
		// The parameter name
		name!: strings.MinRunes(1)

		// The parameter values
		values?: [...strings.MinRunes(1)] & [_, ...]
	}] & [_, ...]

	// Specification for the prober to use for probing targets.
	// The prober.URL parameter is required. Targets cannot be probed
	// if left empty.
	prober?: {
		// `noProxy` is a comma-separated string that can contain IPs,
		// CIDR notation, domain names
		// that should be excluded from proxying. IP and domain names can
		// contain port numbers.
		//
		// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or
		// Thanos >= v0.32.0.
		noProxy?: string

		// Path to collect metrics from.
		// Defaults to `/probe`.
		path?: string

		// ProxyConnectHeader optionally specifies headers to send to
		// proxies during CONNECT requests.
		//
		// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or
		// Thanos >= v0.32.0.
		proxyConnectHeader?: {
			[string]: [...{
				// The key of the secret to select from. Must be a valid secret
				// key.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}]
		}

		// Whether to use the proxy configuration defined by environment
		// variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
		//
		// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or
		// Thanos >= v0.32.0.
		proxyFromEnvironment?: bool

		// `proxyURL` defines the HTTP proxy server to use.
		proxyUrl?: =~"^(http|https|socks5)://.+$"

		// HTTP scheme to use for scraping.
		// `http` and `https` are the expected values unless you rewrite
		// the `__scheme__` label via relabeling.
		// If empty, Prometheus uses the default value `http`.
		scheme?: "http" | "https"

		// Mandatory URL of the prober.
		url!: string
	}

	// SampleLimit defines per-scrape limit on number of scraped
	// samples that will be accepted.
	sampleLimit?: int64

	// The scrape class to apply.
	scrapeClass?: strings.MinRunes(1)

	// Whether to scrape a classic histogram that is also exposed as a
	// native histogram.
	// It requires Prometheus >= v2.45.0.
	//
	// Notice: `scrapeClassicHistograms` corresponds to the
	// `always_scrape_classic_histograms` field in the Prometheus
	// configuration.
	scrapeClassicHistograms?: bool

	// `scrapeProtocols` defines the protocols to negotiate during a
	// scrape. It tells clients the
	// protocols supported by Prometheus in order of preference (from
	// most to least preferred).
	//
	// If unset, Prometheus uses its default value.
	//
	// It requires Prometheus >= v2.49.0.
	scrapeProtocols?: [..."PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0"]

	// Timeout for scraping metrics from the Prometheus exporter.
	// If not specified, the Prometheus global scrape timeout is used.
	// The value cannot be greater than the scrape interval otherwise
	// the operator will reject the resource.
	scrapeTimeout?: =~"^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"

	// TargetLimit defines a limit on the number of scraped targets
	// that will be accepted.
	targetLimit?: int64

	// Targets defines a set of static or dynamically discovered
	// targets to probe.
	targets?: {
		// ingress defines the Ingress objects to probe and the relabeling
		// configuration.
		// If `staticConfig` is also defined, `staticConfig` takes
		// precedence.
		ingress?: {
			// From which namespaces to select Ingress objects.
			namespaceSelector?: {
				// Boolean describing whether all namespaces are selected in
				// contrast to a
				// list restricting them.
				any?: bool

				// List of namespace names to select from.
				matchNames?: [...string]
			}

			// RelabelConfigs to apply to the label set of the target before
			// it gets
			// scraped.
			// The original ingress address is available via the
			// `__tmp_prometheus_ingress_address` label. It can be used to
			// customize the
			// probed URL.
			// The original scrape job's name is available via the
			// `__tmp_prometheus_job_name` label.
			// More info:
			// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
			relabelingConfigs?: [...{
				// Action to perform based on the regex matching.
				//
				// `Uppercase` and `Lowercase` actions require Prometheus >=
				// v2.36.0.
				// `DropEqual` and `KeepEqual` actions require Prometheus >=
				// v2.41.0.
				//
				// Default: "Replace"
				action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual"

				// Modulus to take of the hash of the source label values.
				//
				// Only applicable when the action is `HashMod`.
				modulus?: int64

				// Regular expression against which the extracted value is
				// matched.
				regex?: string

				// Replacement value against which a Replace action is performed
				// if the
				// regular expression matches.
				//
				// Regex capture groups are available.
				replacement?: string

				// Separator is the string between concatenated SourceLabels.
				separator?: string

				// The source labels select values from existing labels. Their
				// content is
				// concatenated using the configured Separator and matched against
				// the
				// configured regular expression.
				sourceLabels?: [...=~"^[a-zA-Z_][a-zA-Z0-9_]*$"]

				// Label to which the resulting string is written in a
				// replacement.
				//
				// It is mandatory for `Replace`, `HashMod`, `Lowercase`,
				// `Uppercase`,
				// `KeepEqual` and `DropEqual` actions.
				//
				// Regex capture groups are available.
				targetLabel?: string
			}]

			// Selector to select the Ingress objects.
			selector?: {
				// matchExpressions is a list of label selector requirements. The
				// requirements are ANDed.
				matchExpressions?: [...{
					// key is the label key that the selector applies to.
					key!: string

					// operator represents a key's relationship to a set of values.
					// Valid operators are In, NotIn, Exists and DoesNotExist.
					operator!: string

					// values is an array of string values. If the operator is In or
					// NotIn,
					// the values array must be non-empty. If the operator is Exists
					// or DoesNotExist,
					// the values array must be empty. This array is replaced during a
					// strategic
					// merge patch.
					values?: [...string]
				}]

				// matchLabels is a map of {key,value} pairs. A single {key,value}
				// in the matchLabels
				// map is equivalent to an element of matchExpressions, whose key
				// field is "key", the
				// operator is "In", and the values array contains only "value".
				// The requirements are ANDed.
				matchLabels?: {
					[string]: string
				}
			}
		}

		// staticConfig defines the static list of targets to probe and
		// the
		// relabeling configuration.
		// If `ingress` is also defined, `staticConfig` takes precedence.
		// More info:
		// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
		staticConfig?: {
			// Labels assigned to all metrics scraped from the targets.
			labels?: {
				[string]: string
			}

			// RelabelConfigs to apply to the label set of the targets before
			// it gets
			// scraped.
			// More info:
			// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
			relabelingConfigs?: [...{
				// Action to perform based on the regex matching.
				//
				// `Uppercase` and `Lowercase` actions require Prometheus >=
				// v2.36.0.
				// `DropEqual` and `KeepEqual` actions require Prometheus >=
				// v2.41.0.
				//
				// Default: "Replace"
				action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual"

				// Modulus to take of the hash of the source label values.
				//
				// Only applicable when the action is `HashMod`.
				modulus?: int64

				// Regular expression against which the extracted value is
				// matched.
				regex?: string

				// Replacement value against which a Replace action is performed
				// if the
				// regular expression matches.
				//
				// Regex capture groups are available.
				replacement?: string

				// Separator is the string between concatenated SourceLabels.
				separator?: string

				// The source labels select values from existing labels. Their
				// content is
				// concatenated using the configured Separator and matched against
				// the
				// configured regular expression.
				sourceLabels?: [...=~"^[a-zA-Z_][a-zA-Z0-9_]*$"]

				// Label to which the resulting string is written in a
				// replacement.
				//
				// It is mandatory for `Replace`, `HashMod`, `Lowercase`,
				// `Uppercase`,
				// `KeepEqual` and `DropEqual` actions.
				//
				// Regex capture groups are available.
				targetLabel?: string
			}]

			// The list of hosts to probe.
			static?: [...string]
		}
	}

	// TLS configuration to use when scraping the endpoint.
	tlsConfig?: {
		// Certificate authority used when verifying server certificates.
		ca?: {
			// ConfigMap containing data to use for the targets.
			configMap?: {
				// The key to select.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the ConfigMap or its key must be defined
				optional?: bool
			}

			// Secret containing data to use for the targets.
			secret?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}
		}

		// Client certificate to present when doing client-authentication.
		cert?: {
			// ConfigMap containing data to use for the targets.
			configMap?: {
				// The key to select.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the ConfigMap or its key must be defined
				optional?: bool
			}

			// Secret containing data to use for the targets.
			secret?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}
		}

		// Disable target certificate validation.
		insecureSkipVerify?: bool

		// Secret containing the client key file for the targets.
		keySecret?: {
			// The key of the secret to select from. Must be a valid secret
			// key.
			key!: string

			// Name of the referent.
			// This field is effectively required, but due to backwards
			// compatibility is
			// allowed to be empty. Instances of this type with an empty value
			// here are
			// almost certainly wrong.
			// More info:
			// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			name?: string

			// Specify whether the Secret or its key must be defined
			optional?: bool
		}

		// Maximum acceptable TLS version.
		//
		// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
		maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13"

		// Minimum acceptable TLS version.
		//
		// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
		minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13"

		// Used to verify the hostname for the targets.
		serverName?: string
	}
}
