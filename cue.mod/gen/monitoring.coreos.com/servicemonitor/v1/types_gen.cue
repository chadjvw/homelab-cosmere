// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni mod vendor crd -f https://github.com/prometheus-community/helm-charts/raw/refs/heads/main/charts/kube-prometheus-stack/charts/crds/crds/crd-servicemonitors.yaml

package v1

import "strings"

// The `ServiceMonitor` custom resource definition (CRD) defines
// how `Prometheus` and `PrometheusAgent` can scrape metrics from
// a group of services.
// Among other things, it allows to specify:
// * The services to scrape via label selectors.
// * The container ports to scrape.
// * Authentication credentials to use.
// * Target and metric relabeling.
//
// `Prometheus` and `PrometheusAgent` objects select
// `ServiceMonitor` objects using label and namespace selectors.
#ServiceMonitor: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "monitoring.coreos.com/v1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "ServiceMonitor"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace!: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// Specification of desired Service selection for target discovery
	// by
	// Prometheus.
	spec!: #ServiceMonitorSpec
}

// Specification of desired Service selection for target discovery
// by
// Prometheus.
#ServiceMonitorSpec: {
	attachMetadata?: {
		// When set to true, Prometheus attaches node metadata to the
		// discovered
		// targets.
		//
		// The Prometheus service account must have the `list` and `watch`
		// permissions on the `Nodes` objects.
		node?: bool
	}

	// When defined, bodySizeLimit specifies a job level limit on the
	// size
	// of uncompressed response body that will be accepted by
	// Prometheus.
	//
	// It requires Prometheus >= v2.28.0.
	bodySizeLimit?: =~"(^0|([0-9]*[.])?[0-9]+((K|M|G|T|E|P)i?)?B)$"

	// Whether to convert all scraped classic histograms into a native
	// histogram with custom buckets.
	// It requires Prometheus >= v3.0.0.
	convertClassicHistogramsToNHCB?: bool

	// List of endpoints part of this ServiceMonitor.
	// Defines how to scrape metrics from Kubernetes
	// [Endpoints](https://kubernetes.io/docs/concepts/services-networking/service/#endpoints)
	// objects.
	// In most cases, an Endpoints object is backed by a Kubernetes
	// [Service](https://kubernetes.io/docs/concepts/services-networking/service/)
	// object with the same name and labels.
	endpoints!: [...{
		// `authorization` configures the Authorization header credentials
		// to use when
		// scraping the target.
		//
		// Cannot be set at the same time as `basicAuth`, or `oauth2`.
		authorization?: {
			// Selects a key of a Secret in the namespace that contains the
			// credentials for authentication.
			credentials?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// Defines the authentication type. The value is case-insensitive.
			//
			// "Basic" is not a supported value.
			//
			// Default: "Bearer"
			type?: string
		}

		// `basicAuth` configures the Basic Authentication credentials to
		// use when
		// scraping the target.
		//
		// Cannot be set at the same time as `authorization`, or `oauth2`.
		basicAuth?: {
			// `password` specifies a key of a Secret containing the password
			// for
			// authentication.
			password?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// `username` specifies a key of a Secret containing the username
			// for
			// authentication.
			username?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}
		}

		// File to read bearer token for scraping the target.
		//
		// Deprecated: use `authorization` instead.
		bearerTokenFile?: string

		// `bearerTokenSecret` specifies a key of a Secret containing the
		// bearer
		// token for scraping targets. The secret needs to be in the same
		// namespace
		// as the ServiceMonitor object and readable by the Prometheus
		// Operator.
		//
		// Deprecated: use `authorization` instead.
		bearerTokenSecret?: {
			// The key of the secret to select from. Must be a valid secret
			// key.
			key!: string

			// Name of the referent.
			// This field is effectively required, but due to backwards
			// compatibility is
			// allowed to be empty. Instances of this type with an empty value
			// here are
			// almost certainly wrong.
			// More info:
			// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
			name?: string

			// Specify whether the Secret or its key must be defined
			optional?: bool
		}

		// `enableHttp2` can be used to disable HTTP2 when scraping the
		// target.
		enableHttp2?: bool

		// When true, the pods which are not running (e.g. either in
		// Failed or
		// Succeeded state) are dropped during the target discovery.
		//
		// If unset, the filtering is enabled.
		//
		// More info:
		// https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
		filterRunning?: bool

		// `followRedirects` defines whether the scrape requests should
		// follow HTTP
		// 3xx redirects.
		followRedirects?: bool

		// When true, `honorLabels` preserves the metric's labels when
		// they collide
		// with the target's labels.
		honorLabels?: bool

		// `honorTimestamps` controls whether Prometheus preserves the
		// timestamps
		// when exposed by the target.
		honorTimestamps?: bool

		// Interval at which Prometheus scrapes the metrics from the
		// target.
		//
		// If empty, Prometheus uses the global scrape interval.
		interval?: =~"^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"

		// `metricRelabelings` configures the relabeling rules to apply to
		// the
		// samples before ingestion.
		metricRelabelings?: [...{
			// Action to perform based on the regex matching.
			//
			// `Uppercase` and `Lowercase` actions require Prometheus >=
			// v2.36.0.
			// `DropEqual` and `KeepEqual` actions require Prometheus >=
			// v2.41.0.
			//
			// Default: "Replace"
			action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual"

			// Modulus to take of the hash of the source label values.
			//
			// Only applicable when the action is `HashMod`.
			modulus?: int64

			// Regular expression against which the extracted value is
			// matched.
			regex?: string

			// Replacement value against which a Replace action is performed
			// if the
			// regular expression matches.
			//
			// Regex capture groups are available.
			replacement?: string

			// Separator is the string between concatenated SourceLabels.
			separator?: string

			// The source labels select values from existing labels. Their
			// content is
			// concatenated using the configured Separator and matched against
			// the
			// configured regular expression.
			sourceLabels?: [...=~"^[a-zA-Z_][a-zA-Z0-9_]*$"]

			// Label to which the resulting string is written in a
			// replacement.
			//
			// It is mandatory for `Replace`, `HashMod`, `Lowercase`,
			// `Uppercase`,
			// `KeepEqual` and `DropEqual` actions.
			//
			// Regex capture groups are available.
			targetLabel?: string
		}]

		// `noProxy` is a comma-separated string that can contain IPs,
		// CIDR notation, domain names
		// that should be excluded from proxying. IP and domain names can
		// contain port numbers.
		//
		// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or
		// Thanos >= v0.32.0.
		noProxy?: string

		// `oauth2` configures the OAuth2 settings to use when scraping
		// the target.
		//
		// It requires Prometheus >= 2.27.0.
		//
		// Cannot be set at the same time as `authorization`, or
		// `basicAuth`.
		oauth2?: {
			// `clientId` specifies a key of a Secret or ConfigMap containing
			// the
			// OAuth2 client's ID.
			clientId!: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// `clientSecret` specifies a key of a Secret containing the
			// OAuth2
			// client's secret.
			clientSecret!: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// `endpointParams` configures the HTTP parameters to append to
			// the token
			// URL.
			endpointParams?: {
				[string]: string
			}

			// `noProxy` is a comma-separated string that can contain IPs,
			// CIDR notation, domain names
			// that should be excluded from proxying. IP and domain names can
			// contain port numbers.
			//
			// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or
			// Thanos >= v0.32.0.
			noProxy?: string

			// ProxyConnectHeader optionally specifies headers to send to
			// proxies during CONNECT requests.
			//
			// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or
			// Thanos >= v0.32.0.
			proxyConnectHeader?: {
				[string]: [...{
					// The key of the secret to select from. Must be a valid secret
					// key.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}]
			}

			// Whether to use the proxy configuration defined by environment
			// variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
			//
			// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or
			// Thanos >= v0.32.0.
			proxyFromEnvironment?: bool

			// `proxyURL` defines the HTTP proxy server to use.
			proxyUrl?: =~"^(http|https|socks5)://.+$"

			// `scopes` defines the OAuth2 scopes used for the token request.
			scopes?: [...string]

			// TLS configuration to use when connecting to the OAuth2 server.
			// It requires Prometheus >= v2.43.0.
			tlsConfig?: {
				// Certificate authority used when verifying server certificates.
				ca?: {
					// ConfigMap containing data to use for the targets.
					configMap?: {
						// The key to select.
						key!: string

						// Name of the referent.
						// This field is effectively required, but due to backwards
						// compatibility is
						// allowed to be empty. Instances of this type with an empty value
						// here are
						// almost certainly wrong.
						// More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// Specify whether the ConfigMap or its key must be defined
						optional?: bool
					}

					// Secret containing data to use for the targets.
					secret?: {
						// The key of the secret to select from. Must be a valid secret
						// key.
						key!: string

						// Name of the referent.
						// This field is effectively required, but due to backwards
						// compatibility is
						// allowed to be empty. Instances of this type with an empty value
						// here are
						// almost certainly wrong.
						// More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// Specify whether the Secret or its key must be defined
						optional?: bool
					}
				}

				// Client certificate to present when doing client-authentication.
				cert?: {
					// ConfigMap containing data to use for the targets.
					configMap?: {
						// The key to select.
						key!: string

						// Name of the referent.
						// This field is effectively required, but due to backwards
						// compatibility is
						// allowed to be empty. Instances of this type with an empty value
						// here are
						// almost certainly wrong.
						// More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// Specify whether the ConfigMap or its key must be defined
						optional?: bool
					}

					// Secret containing data to use for the targets.
					secret?: {
						// The key of the secret to select from. Must be a valid secret
						// key.
						key!: string

						// Name of the referent.
						// This field is effectively required, but due to backwards
						// compatibility is
						// allowed to be empty. Instances of this type with an empty value
						// here are
						// almost certainly wrong.
						// More info:
						// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
						name?: string

						// Specify whether the Secret or its key must be defined
						optional?: bool
					}
				}

				// Disable target certificate validation.
				insecureSkipVerify?: bool

				// Secret containing the client key file for the targets.
				keySecret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}

				// Maximum acceptable TLS version.
				//
				// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
				maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13"

				// Minimum acceptable TLS version.
				//
				// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
				minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13"

				// Used to verify the hostname for the targets.
				serverName?: string
			}

			// `tokenURL` configures the URL to fetch the token from.
			tokenUrl!: strings.MinRunes(1)
		}

		// params define optional HTTP URL parameters.
		params?: {
			[string]: [...string]
		}

		// HTTP path from which to scrape for metrics.
		//
		// If empty, Prometheus uses the default value (e.g. `/metrics`).
		path?: string

		// Name of the Service port which this endpoint refers to.
		//
		// It takes precedence over `targetPort`.
		port?: string

		// ProxyConnectHeader optionally specifies headers to send to
		// proxies during CONNECT requests.
		//
		// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or
		// Thanos >= v0.32.0.
		proxyConnectHeader?: {
			[string]: [...{
				// The key of the secret to select from. Must be a valid secret
				// key.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}]
		}

		// Whether to use the proxy configuration defined by environment
		// variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
		//
		// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or
		// Thanos >= v0.32.0.
		proxyFromEnvironment?: bool

		// `proxyURL` defines the HTTP proxy server to use.
		proxyUrl?: =~"^(http|https|socks5)://.+$"

		// `relabelings` configures the relabeling rules to apply the
		// target's
		// metadata labels.
		//
		// The Operator automatically adds relabelings for a few standard
		// Kubernetes fields.
		//
		// The original scrape job's name is available via the
		// `__tmp_prometheus_job_name` label.
		//
		// More info:
		// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
		relabelings?: [...{
			// Action to perform based on the regex matching.
			//
			// `Uppercase` and `Lowercase` actions require Prometheus >=
			// v2.36.0.
			// `DropEqual` and `KeepEqual` actions require Prometheus >=
			// v2.41.0.
			//
			// Default: "Replace"
			action?: "replace" | "Replace" | "keep" | "Keep" | "drop" | "Drop" | "hashmod" | "HashMod" | "labelmap" | "LabelMap" | "labeldrop" | "LabelDrop" | "labelkeep" | "LabelKeep" | "lowercase" | "Lowercase" | "uppercase" | "Uppercase" | "keepequal" | "KeepEqual" | "dropequal" | "DropEqual"

			// Modulus to take of the hash of the source label values.
			//
			// Only applicable when the action is `HashMod`.
			modulus?: int64

			// Regular expression against which the extracted value is
			// matched.
			regex?: string

			// Replacement value against which a Replace action is performed
			// if the
			// regular expression matches.
			//
			// Regex capture groups are available.
			replacement?: string

			// Separator is the string between concatenated SourceLabels.
			separator?: string

			// The source labels select values from existing labels. Their
			// content is
			// concatenated using the configured Separator and matched against
			// the
			// configured regular expression.
			sourceLabels?: [...=~"^[a-zA-Z_][a-zA-Z0-9_]*$"]

			// Label to which the resulting string is written in a
			// replacement.
			//
			// It is mandatory for `Replace`, `HashMod`, `Lowercase`,
			// `Uppercase`,
			// `KeepEqual` and `DropEqual` actions.
			//
			// Regex capture groups are available.
			targetLabel?: string
		}]

		// HTTP scheme to use for scraping.
		//
		// `http` and `https` are the expected values unless you rewrite
		// the
		// `__scheme__` label via relabeling.
		//
		// If empty, Prometheus uses the default value `http`.
		scheme?: "http" | "https"

		// Timeout after which Prometheus considers the scrape to be
		// failed.
		//
		// If empty, Prometheus uses the global scrape timeout unless it
		// is less
		// than the target's scrape interval value in which the latter is
		// used.
		// The value cannot be greater than the scrape interval otherwise
		// the operator will reject the resource.
		scrapeTimeout?: =~"^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"

		// Name or number of the target port of the `Pod` object behind
		// the
		// Service. The port must be specified with the container's port
		// property.
		targetPort?: matchN(>=1, [int, string])

		// TLS configuration to use when scraping the target.
		tlsConfig?: {
			// Certificate authority used when verifying server certificates.
			ca?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Path to the CA cert in the Prometheus container to use for the
			// targets.
			caFile?: string

			// Client certificate to present when doing client-authentication.
			cert?: {
				// ConfigMap containing data to use for the targets.
				configMap?: {
					// The key to select.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the ConfigMap or its key must be defined
					optional?: bool
				}

				// Secret containing data to use for the targets.
				secret?: {
					// The key of the secret to select from. Must be a valid secret
					// key.
					key!: string

					// Name of the referent.
					// This field is effectively required, but due to backwards
					// compatibility is
					// allowed to be empty. Instances of this type with an empty value
					// here are
					// almost certainly wrong.
					// More info:
					// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
					name?: string

					// Specify whether the Secret or its key must be defined
					optional?: bool
				}
			}

			// Path to the client cert file in the Prometheus container for
			// the targets.
			certFile?: string

			// Disable target certificate validation.
			insecureSkipVerify?: bool

			// Path to the client key file in the Prometheus container for the
			// targets.
			keyFile?: string

			// Secret containing the client key file for the targets.
			keySecret?: {
				// The key of the secret to select from. Must be a valid secret
				// key.
				key!: string

				// Name of the referent.
				// This field is effectively required, but due to backwards
				// compatibility is
				// allowed to be empty. Instances of this type with an empty value
				// here are
				// almost certainly wrong.
				// More info:
				// https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
				name?: string

				// Specify whether the Secret or its key must be defined
				optional?: bool
			}

			// Maximum acceptable TLS version.
			//
			// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
			maxVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13"

			// Minimum acceptable TLS version.
			//
			// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
			minVersion?: "TLS10" | "TLS11" | "TLS12" | "TLS13"

			// Used to verify the hostname for the targets.
			serverName?: string
		}

		// `trackTimestampsStaleness` defines whether Prometheus tracks
		// staleness of
		// the metrics that have an explicit timestamp present in scraped
		// data.
		// Has no effect if `honorTimestamps` is false.
		//
		// It requires Prometheus >= v2.48.0.
		trackTimestampsStaleness?: bool
	}]

	// The protocol to use if a scrape returns blank, unparseable, or
	// otherwise invalid Content-Type.
	//
	// It requires Prometheus >= v3.0.0.
	fallbackScrapeProtocol?: "PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0"

	// `jobLabel` selects the label from the associated Kubernetes
	// `Service`
	// object which will be used as the `job` label for all metrics.
	//
	// For example if `jobLabel` is set to `foo` and the Kubernetes
	// `Service`
	// object is labeled with `foo: bar`, then Prometheus adds the
	// `job="bar"`
	// label to all ingested metrics.
	//
	// If the value of this field is empty or if the label doesn't
	// exist for
	// the given Service, the `job` label of the metrics defaults to
	// the name
	// of the associated Kubernetes `Service`.
	jobLabel?: string

	// Per-scrape limit on the number of targets dropped by relabeling
	// that will be kept in memory. 0 means no limit.
	//
	// It requires Prometheus >= v2.47.0.
	keepDroppedTargets?: int64

	// Per-scrape limit on number of labels that will be accepted for
	// a sample.
	//
	// It requires Prometheus >= v2.27.0.
	labelLimit?: int64

	// Per-scrape limit on length of labels name that will be accepted
	// for a sample.
	//
	// It requires Prometheus >= v2.27.0.
	labelNameLengthLimit?: int64

	// Per-scrape limit on length of labels value that will be
	// accepted for a sample.
	//
	// It requires Prometheus >= v2.27.0.
	labelValueLengthLimit?: int64

	// `namespaceSelector` defines in which namespace(s) Prometheus
	// should discover the services.
	// By default, the services are discovered in the same namespace
	// as the `ServiceMonitor` object but it is possible to select
	// pods across different/all namespaces.
	namespaceSelector?: {
		// Boolean describing whether all namespaces are selected in
		// contrast to a
		// list restricting them.
		any?: bool

		// List of namespace names to select from.
		matchNames?: [...string]
	}

	// If there are more than this many buckets in a native histogram,
	// buckets will be merged to stay within the limit.
	// It requires Prometheus >= v2.45.0.
	nativeHistogramBucketLimit?: int64

	// If the growth factor of one bucket to the next is smaller than
	// this,
	// buckets will be merged to increase the factor sufficiently.
	// It requires Prometheus >= v2.50.0.
	nativeHistogramMinBucketFactor?: matchN(>=1, [int, string]) & (number | =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$")

	// `podTargetLabels` defines the labels which are transferred from
	// the
	// associated Kubernetes `Pod` object onto the ingested metrics.
	podTargetLabels?: [...string]

	// `sampleLimit` defines a per-scrape limit on the number of
	// scraped samples
	// that will be accepted.
	sampleLimit?: int64

	// The scrape class to apply.
	scrapeClass?: strings.MinRunes(1)

	// Whether to scrape a classic histogram that is also exposed as a
	// native histogram.
	// It requires Prometheus >= v2.45.0.
	//
	// Notice: `scrapeClassicHistograms` corresponds to the
	// `always_scrape_classic_histograms` field in the Prometheus
	// configuration.
	scrapeClassicHistograms?: bool

	// `scrapeProtocols` defines the protocols to negotiate during a
	// scrape. It tells clients the
	// protocols supported by Prometheus in order of preference (from
	// most to least preferred).
	//
	// If unset, Prometheus uses its default value.
	//
	// It requires Prometheus >= v2.49.0.
	scrapeProtocols?: [..."PrometheusProto" | "OpenMetricsText0.0.1" | "OpenMetricsText1.0.0" | "PrometheusText0.0.4" | "PrometheusText1.0.0"]

	// Label selector to select the Kubernetes `Endpoints` objects to
	// scrape metrics from.
	selector!: {
		// matchExpressions is a list of label selector requirements. The
		// requirements are ANDed.
		matchExpressions?: [...{
			// key is the label key that the selector applies to.
			key!: string

			// operator represents a key's relationship to a set of values.
			// Valid operators are In, NotIn, Exists and DoesNotExist.
			operator!: string

			// values is an array of string values. If the operator is In or
			// NotIn,
			// the values array must be non-empty. If the operator is Exists
			// or DoesNotExist,
			// the values array must be empty. This array is replaced during a
			// strategic
			// merge patch.
			values?: [...string]
		}]

		// matchLabels is a map of {key,value} pairs. A single {key,value}
		// in the matchLabels
		// map is equivalent to an element of matchExpressions, whose key
		// field is "key", the
		// operator is "In", and the values array contains only "value".
		// The requirements are ANDed.
		matchLabels?: {
			[string]: string
		}
	}

	// Mechanism used to select the endpoints to scrape.
	// By default, the selection process relies on relabel
	// configurations to filter the discovered targets.
	// Alternatively, you can opt in for role selectors, which may
	// offer better efficiency in large clusters.
	// Which strategy is best for your use case needs to be carefully
	// evaluated.
	//
	// It requires Prometheus >= v2.17.0.
	selectorMechanism?: "RelabelConfig" | "RoleSelector"

	// `targetLabels` defines the labels which are transferred from
	// the
	// associated Kubernetes `Service` object onto the ingested
	// metrics.
	targetLabels?: [...string]

	// `targetLimit` defines a limit on the number of scraped targets
	// that will
	// be accepted.
	targetLimit?: int64
}
